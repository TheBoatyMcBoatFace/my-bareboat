= Estimating wave height from IMU accelerometer on a moving boat (Early Draft)
mgrouch <mgrouch@users.noreply.github.com>
{docdate}, Wave Height from IMU accelerometer
:imagesdir: images
:doctype: book
:organization: Bareboat Necessities
:description: Bareboat Necessities, Wave Height from IMU accelerometer
:title-logo-image: image:bareboat-necessities-logo.svg[Bareboat Necessities Logo]
ifdef::backend-pdf[]
:source-highlighter: rouge
:toc-placement!: manual
:pdf-page-size: Letter
:plantumlconfig: plantuml.cfg
endif::[]
ifndef::backend-pdf[]
:toc-placement: manual
endif::[]
:stem:
:experimental:
:reproducible:
:toclevels: 4
:sectnums:
:sectnumlevels: 3
:encoding: utf-8
:lang: en
:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:env-github:

{zwsp} +

ifndef::backend-pdf[]

image::bareboat-necessities-logo.svg[Bareboat Necessities Logo]

{zwsp} +

== Abstract

Usual methods for measuring elevation built-in into modern smartwatches and smart devices are based on fusion of data
(using Kalman filters, etc) from IMU (accelerometer) and barometer sensors. These methods are designed to measure steps up and down stairs,
hiking activities, and so on. However, using pressure as a useful source of elevation data is not suitable to measure
the wave height from a boat. The surface of the wave itself (at least in trochoidal wave model) is the surface of
equal pressure. Real waves are more complicated but nevertheless measuring air pressure on their surface
to estimate amplitude of the wave would lead to measuring mostly noise.

Calculating elevation (displacement) using double integration of the acceleration leads
to huge result drift due to not knowing initial displacement, initial vertical velocity
and due to signal noise and accelerometer bias.

This article describes two different methods to estimate wave height, frequency, period
from a moving boat using IMU (accelerometer) and other common boat sensors such as anemometer (wind), GPS, and compass.
One method is based on Kalman method which calculates second integral of acceleration with a drift correction
based on the fact that in wave average displacement equals to zero. Another method doesn't use
integration at all. Instead, it measures max/min acceleration and assumes wave shape to be trochoidal.
Based on max/min acceleration and observed wave frequency (later adjusted using Doppler effect formulas)
the method recreates parameters of the trochoid wave allowing it to estimate the wave height.

== Trochoidal Waves

Gravitational {nbsp} stem:[g] {nbsp} (m/s^2): {nbsp}{nbsp}{nbsp}
stem:[g = 9.81]

Rotation center of trochoidal wave particle in Z axis (always negative) (m): {nbsp}{nbsp}{nbsp}
stem:[b]

Wavelength (m): {nbsp}{nbsp}{nbsp}
stem:[L]

Wave equation:

stem:[X(t) = H sin(k c t)]

stem:[Z(t) = - H cos(k c t)]

Wavenumber (1/m): {nbsp}{nbsp}{nbsp}
stem:[k = (2 pi) / L]

Wave amplitude (m):  {nbsp}{nbsp}{nbsp}
stem:[H = e ^(k b) / k = L / (2 pi) e ^ ((2 pi b) / L)  ] {nbsp}{nbsp}{nbsp} => {nbsp}{nbsp}{nbsp}
stem:[b = ln(H k) / k = L / (2 pi) ln ((2 pi H) / L)  ]

max(H) amplitude (m):   {nbsp}{nbsp}{nbsp}  stem:[H_max = L / (2 pi)] {nbsp}{nbsp}{nbsp} when {nbsp} b = 0

Depth (m): {nbsp}{nbsp}{nbsp}
stem:[d]

Wave speed (m/s): {nbsp}{nbsp}{nbsp}
stem:[c = sqrt(g / k tanh(k d))] {nbsp},{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}
for deep water waves: stem:[c = sqrt(g / k) = sqrt((g L) / (2 pi))],  {nbsp}{nbsp} stem:[L = (g T ^ 2) / (2 pi)]

Wave period (s):   {nbsp}{nbsp}{nbsp}
stem:[T = L / c]

Wave frequency (Hz=1/s):   {nbsp}{nbsp}{nbsp}
stem:[f = 1 / T = c / L]

Vertical motion is harmonic.

Vertical displacement:
stem:[Z(t) = - H cos(k c t)]

Vertical velocity:
stem:[u(t) = Z^'(t) = k c H sin(k c t)]

Vertical acceleration:
stem:[a(t) = u^'(t) = k^2 c^2 H cos(k c t)]

stem:[a_max = -a_min = k^2 c^2 H =  ((2 pi) / L) ^ 2 ((g L) / (2 pi)) L / (2 pi) e^((2 pi b)/L) = g e^((2 pi b)/L)  ]

stem:[b = L / (2 pi) ln(a_max / g)]

=== Doppler effect:

stem:[f] {nbsp} is emitted frequency (Hz=1/s),

stem:[f_o] {nbsp} is observed frequency (Hz=1/s):

stem:[c] {nbsp} is the propagation speed of waves in the medium

stem:[Delta v] {nbsp} is the opposite of the velocity of the receiver
relative to the source: it is positive when the source and the receiver are moving towards each other.

stem:[f_o = (c +- Delta v) / c f]

stem:[L] {nbsp} is source wavelength (m) for trochoidal wave.

For trochoidal wave:

stem:[f = c / L] {nbsp} => {nbsp} stem:[f_o = (c +- Delta v) / L ],

stem:[c = sqrt((g L) / (2 pi))] {nbsp} => {nbsp} stem:[f_0 = (sqrt((g L) / (2 pi)) +- Delta v) / L]

stem:[L = (sign(Delta v) sqrt(8 pi f_o g  Delta v + g ^ 2) + 4 pi f_o  Delta v + g) / (4 pi f_o ^ 2)]

=== Trigonometry of a boat movement

==== Terminology

_AWS_ {nbsp} is Apparent Wind Speed (relative to the boat heading)

_AWA_ {nbsp} is Apparent Wind Angle (relative to the bow heading, 0 to 180, starboard plus, port minus)

_AWD_ {nbsp} is Apparent Wind Direction (relative to true north)

_AGWS_ {nbsp} is Apparent Ground Wind Speed (relative to the boat course over the ground)

_AGWA_ {nbsp} is Apparent Ground Wind Angle (relative to the boat course over the ground, 0 to 180, starboard plus, port minus)

_AGWD_ {nbsp} is Apparent Ground Wind Direction (relative to true north)

_SPD_ {nbsp} is Knotmeter speed (relative to the water)

_HDT_ {nbsp} is Heading true (relative to true north)

_HDM_ {nbsp} is  Heading magnetic (relative to magnetic north)

_DFT_ {nbsp} is  Current Drift (speed of current, relative to fixed earth)

_SET_ {nbsp} is  Current Set (direction current flows toward relative to fixed earth true north)

_SOG_ {nbsp} is  Speed Over Ground (relative to the fixed earth)

_COGT_ {nbsp} is Course Over Ground true (relative to the fixed earth true north)

_COGM_ {nbsp} is Course Over Ground magnetic (relative to the fixed earth magnetic north)

_GWS_ {nbsp} is Ground Wind Speed (relative to the fixed earth)

_GWD_ {nbsp} is Ground Wind Direction (relative to true north)

_TWA_ {nbsp} is True Wind Angle (relative to the heading, 0 = upwind, 180deg = downwind, (+ starboard, - port))

_TWS_ {nbsp} is True Wind Speed (relative to the water)

_TWD_ {nbsp} is True Wind Direction (relative to true north)

_POS_ {nbsp} is position LAT, LON (latitude, longitude)

_TB(POS1, POS2)_ {nbsp} is Bearing true (true north angle to maintain in course to reach from POS1 to POS2)

==== Calculating true wind and speed through water based on difference in heading and course over ground

Having both true heading and true course over the ground allows calculating true wind vector parameters and
speed through the water (SPD):

stem:[SPD = ((dist(POS2, POS1)) / (t_\text{end} - t_\text{start}) - DFT * cos(COGT - SET)) * cos(COGT - avg(HDT))]

stem:[TWS = sqrt((avg(AWS)) ^ 2 + SPD ^ 2 - 2 * avg(AWS) * SPD * cos(avg(AWA)))]

stem:[TWA = +- arccos((avg(AWS) * cos(avg(AWA)) - SPD) / (TWS))]

For Doppler effect formulas:

stem:[Delta v = SPD * cos(TWA)]


== Measuring wave height from a moving boat


=== Measurable input parameters

Open sea waves have periods 20 sec or even longer. So sample duration time
should be in minutes to capture several waves.

* t_start, t_end - time interval of measurements (about 5 mins)
* POS(t) as LAT(t), LON(t)
* AWA(t) AWS(t)
* COG(t) SOG(t)
* HDM(t) + mag_variation -> HDT(t)
* DFT(t) SET(t) - (possibly from current/tide stations harmonics data)
* heel(t), pitch(t)
* SPD(t) - possibly (might be missing) => leeway(heel(t), SPD(t))
* accel(t, x, y, z), vertical_accel(t) via pitch,roll,heel
* ROT(t) - rate of turn

=== Assumptions

* No tacks, jibes during sample
* Heading is mostly steady
* Trochoidal wave model
* Approx formula for b (in trochoidal wave model)


=== Algorithm steps

Calculation steps:

* FFT to get observed wave frequency from acceleration (f_observed)
* Speed toward wave fronts (delta_v for Doppler frequency) from wind and speed data
+
**  COGT as true bearing from POS1 to POS2
**  Convert HDM to HDT using position and local mag declination, Use avg(HDT) vs COG and coordinates to calculate SPD
**  SPD = (DIST(POS1, POS2)/(t_end - t_start) - (DFT * cos(COGT - SET))) * cos(COGT - avg(HDT))
**  avg(leeway(heel(t), SPD))
**  use avg(AWA), AVG(AWS) and SPD to calculate TWS/TWA
**  TWS = sqrt(AVG(AWS) ^ 2 + SPD ^ 2 - 2 * AVG(AWS) * SPD * cos(avg(AWA)))
**  TWA = +- arccos((AVG(AWS) * cos(avg(AWA)) - SPD) / TWS)
**  calculate delta_v as SPD * cos(TWA)
+
* Calculate L_source (source wave length) for trochoidal wave model from f_observed and delta_v using Doppler formulas
* Low pass filter for accel data
* min/max accel after low pass
* Calculate b value for trochoidal wave model from known L_source and min/max accel after low pass
* Calculate wave height from b and L_source


=== Input validation

* Validate heading and COG for steadiness
* Validate that magnetic variation is known for the position
* Check validity of accel (against g)
* TODO: more

=== Result validation

* Validate wave amplitude max {nbsp} stem:[H_max = L / (2 pi)]
* Validate accel
* TODO: more

endif::[]
